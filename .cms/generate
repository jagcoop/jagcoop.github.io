#!/usr/bin/env nu
use std assert

def main [] { }

def "main build" [] {
	#in main generate .info, rss, sitemap (en ese orden)
	.cms/generate .info ;
	.cms/generate nav
	.cms/generate posts ;
	.cms/generate rss ;
	.cms/generate sitemap;

	rm -rf .puplic_html; mkdir .public_html
	#copies everything except files and directories that start with a dot
	rsync --archive --include=".githu*" --include=".nojekyll" --exclude=".*/"  ./* .public_html/

	#if we are in the branch main,
		#create a new branch html
		#copy all files there except .cms
		#commit y push en el branch
	#else create the branch html-staging
}

def "main .info" []: nothing -> nothing {
	ls **/*
	| where name =~  "index.html"
	| where {|f| (extract_description $f) != "" }
	| each {|f| (extract_description $f)
	  	    |  $"index.html\n\t($in)"
	 		| save --force ($f.name | path dirname | $"./($in)/.info" )}
	| if ($in | is-empty) { null}
}

def "main posts" []: nothing -> nothing {
	process_template ./posts/index.mustache 'html'
}

def "main rss" []: nothing -> nothing {
	process_template ./rss.mustache xml
}

def "main sitemap" []: nothing -> nothing {
	process_template ./sitemap.mustache xml
}

def "main nav" []: nothing -> nothing {
	process_template ./nav.mustache html
}




def process_template [a_template:path, output_extension:string] -> nothing {

	let $jsonata = find_for 'jsonata' $a_template
	let $mustache = find_for 'mustache' $a_template 
	let $html_output_file = new_path_for $output_extension $a_template 

	tree --info --timefmt %Y-%m-%d -H '.' --noreport -J -t -r .
	| jfq  --query-file $jsonata
	| mustache $mustache
	| save --force $html_output_file
}


def find_for [template_extension:string, a_template:path] -> path {
	let template = new_path_for $template_extension $a_template
	assert ($template | path exists) --error-label {
        text: $"Mandatory file: '($template)' doesn't exist",
        span: (metadata $template).span,
    }
	$template
	
}

def new_path_for [template_extension:string, a_template:path ] -> path {
	$a_template | path parse | upsert extension $template_extension | path join
}

def "main .info ls" [] -> table<name: string, type: string, size: filesize, modified: date> (stream) {
	ls **/*	-a | where name =~  ".info" | to tsv
}


def extract_description [f] -> string {
	open $f.name| pup 'meta[name="description"] attr{content}'
}



def "main mustache_build" [] {
# The idea is to pass every file to mustache so that it every file can be "dynamic"
# so for example a file like rss.xml (which should a mustache) can be genarted in .public_html rehydrated
# so 3 cases
# file doesn't have mustache strings then don't pass to mustache
# there is a file with the same name.json then that file passes through mustache
# there is a file with same name.tree2jsonata and should the execute the tree command and process it with jsonata and then pass to mustache
# like currently it does with rss and sitemap
#  ls **/* | each {|f| echo "[]" | mustache $f.name}   
}

