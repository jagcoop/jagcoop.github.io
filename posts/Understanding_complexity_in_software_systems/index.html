 <meta charset="utf-8" emacsmode="-*- markdown -*-">
# Understanding complexity in software systems

September 23th, 2024
by *Julio César*

> Controlling complexity is the essence of computer programming.
> 
> — Brian Kernighan

Recently I&rsquo;ve been enjoying reading &ldquo;A philosophy of software design&rdquo; by John
Ousterhout, the main focus of the book is to learn techniques to reduce
complexity in a software system and use that to drive our design decisions.
Before diving into how to reduce software complexity we might ask, what is
complexity?

Complexity in software is a term that has been explored a lot, I would think
that since we as a society started to depend on software systems to replace
processes that didn&rsquo;t need computers before, we started to observe a toxic pattern
emerging on our code bases.

Software systems never seem to be complete - they seem to always require
changes to be made - so systems have a need to be maintained. However, over
time, the system starts to rot, modifications become harder and harder to
make, this is the main indication of having a complex system in sight. Fred
Brooks wrote something on complexity in his famous book &ldquo;The Mythical
Man-Month: Essays on Software Engineering&rdquo; - from his perspective, there are
two kind of complexities, first, *essential complexity* - the kind of complexity
that exists just because the domain a software models maps to is inherently
complex. The second type of complexity Brooks writes about is *accidental
complexity* which is more in line with the notion of complexity that Ousterhout
documents in his book.

Accidental complexity is what remains when we take essential complexity out of
the picture, it is often the result of lack of skills, bad habits software
developers adopt, or frequently, simply due to an incomplete understanding of
the domain and the problem we are trying to solve. Under Ousterhout&rsquo;s
framework complexity is anything that inhibits change on a software system and
is primarily a consequence of bad software design decisions (be it small or
big) made one after another during a continuously prolonged amount of time. It
is hinted that software complexity is something that can&rsquo;t just be avoided at
all and will always exist but there are practices that help software
developers to manage it.

According to Ousterhout it is paramount to train ourselves to identify
complexity, we cannot start to manage it if we cannot see it in the first
place! In the book we&rsquo;re taught that one way to see complexity is to identify
where in the system we&rsquo;re spending the most time working on, typically, the
more time necessary to change a certain component of a system will hint that
the component is harder to change and therefore complex.

One might also think that beyond time - size of a component is also a good
indicator for presence of complexity in a system, yet this is not true, big
systems aren&rsquo;t necessarily complex, if they are easy to work with then they
remain simple. On the contrary, there could be pieces of code or even a single
instruction that on its own is very hard to understand and change, what is
worse is that in some cases doing the change might impact other parts of the
system unexpectedly, so beware! complexity can hide even behind a single line
of code.

Ousterhout mentions three signs that alert the presence of complexity in a
code-base.

1.  Change amplification
2.  Cognitive load
3.  Unknown unknowns

In the first case, whenever the implementation of even the simplest feature needs
a lot of changes in lots of places of the system it is said we&rsquo;re
suffering of *change amplification* and it is a major *major* sign of accidental
complexity on a software system.

On the second case, whenever the developers need deep understanding of a lot
of context in the code-base to carry out a simple change then *cognitive load*
exists. It follows then that lines of code do not translate to code
complexity, it may be the case that simple changes require lots of lines of
code - or, on the contrary, a complex change could end up being just a single
line change. Cognitive load refers about the context the developer needs to
understand in order to make changes to the system, the bigger that context is
the more complex the system is considered to be.

The third case, &ldquo;Unknown unknowns&rdquo; is a sign of complexity where a developer
doesn&rsquo;t know what or where a change is required to implement a certain
feature; often developers follow a hunch on what needs to be modified to get
the job done, they try out the new feature thinking all is done but then as
soon as it is tested the behaviour reveals the change is incomplete, there&rsquo;s
something the developer didn&rsquo;t anticipate and doesn&rsquo;t understand why the
change they made wasn&rsquo;t sufficient - &ldquo;Why it isn&rsquo;t working yet if I have just
changed this part here?&rdquo;, that&rsquo;s an unknown unknown.

From all the signs of complexity in a software system, having unknown unknowns
is the worst, it reveals deep problems in the design of the system as it is
non-obvious what its structure is and there&rsquo;s no clear path to evolve it in a
sane way.

All in all, these are just signs that we have a complex system in our hands,
but it doesn&rsquo;t give indication of where that complexity is coming from or how
we can tackle it. Ousterhout suggests that complexity is mainly introduced by
*dependencies* and *obscurities* in a software system.

Dependencies exist whenever
the code can&rsquo;t be understood in isolation, or, when changes in a part of the system
also require separate components to be updated, there we have a
dependency.

Obscurity is another form of dependency, but is a non-obvious one, or rather
an indirect dependency where there&rsquo;s nothing in the code that relates two
areas of the code-base that in reality are coupled to each other. Obscurity,
also happens when a variable or symbol refers to two separate concepts, in
this case, there&rsquo;s a dependency but it isn&rsquo;t clear what that dependency
entails or what is affected by changing it. A simple example may be a numeric
variable whose type (or name) does not hint about the &ldquo;units&rdquo; of the value
stored in that variable, e.g. 42 centigrade isn&rsquo;t the same as to 42 minutes. Also,
whenever we need extensive documentation on a component, whether in the code
or outside of it, we can take this as a clear indication that we have
obscurity in the code, or else, what&rsquo;s the need to explain it so thoroughly?

This is a good point to stop our exploration on software complexity, and as
we&rsquo;ve seen complexity is a key aspect to account for if we want to end up with
simpler and maintainable systems; if we can find ways or design techniques
that minimize dependencies and obscurity in our code-base then we&rsquo;ll be able
to reduce the complexity of the system as a whole. In a future post we&rsquo;ll
understand more about both of these aspects of software, and in doing so we&rsquo;ll
be able to come up with good software design decisions that over time will
help us rather than fight against us.


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
