 <meta charset="utf-8" emacsmode="-*- markdown -*-">
# Declarative dotfiles with Home Manager

October 5th, 2024
by *Julio CÃ©sar*

The UNIX philosophy is a set of cultural norms and a philosophical approach to
building minimalist and modular software, the main tenets can be summarized as
follows:

-   Write programs that do one thing and do it well.
-   Write programs to work together.
-   Write programs to handle text streams, because that is a universal interface.

While I am a big supporter of the idea, one consequence of this, is that in a
Linux system one often ends up installing lots of small utilities each one
defining its own configuration files. It is not uncommon to have lots of these
configuration files polluting the home directory, in an attempt to &ldquo;hide&rdquo;
these files their names usually start with a dot (`.`) meaning they are not
listed by programs such as `ls` or any other file browser for that matter, but,
they&rsquo;re still there creating a bigger configuration file collection over time,
these are commonly known as &ldquo;*dotfiles*&rdquo;.

These files end up being treated as code, as they define the state of the
system we use to do our work as software developers, it is not uncommon to
check these files into version control systems so that we&rsquo;re able to share the
same configuration across multiple machines with the added benefit that if we
ever change workstations it would be easier to port our tools over and get to
work right away.

However, managing this files as a software repository starts to become a
problem since we
now need to handle the installation of these files into their correct
locations, not all files need to be in the home directory and not every tool
supports the [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/latest/), more over tools which provide
lots of functionality might end up needed more than one file to configure it.
Symbolic links are often our first attempt to solve this problem but managing
lots of symlinks will sooner or later require some flaky custom scripts that
comes with its own set of problems.

As a neophyte Nix user I had to try Home Manager for solving exactly this
problem, and what a great solution!

Home manager allow us to follow the philosophy of NixOS to manage our dotfiles,
whereas NixOS allow us to configure an entire system state and system-level
properties declaratively using the Nix language, Home Manager allow us to
configure our user-level tooling declaratively using the Nix language.

Nix being nix, defines lots of possible ways to do the same thing, so I will
document bellow the way I&rsquo;m currently using it in combination of Nix Flakes,
a fancy name for &ldquo;*Nix distribution package*&rdquo;.

Within the root of the dotfiles repo define a `flake.nix` file with the
following:

    {
        # Adds a sample description as metadata for this flake
        description = "This Flake manages my dotfiles";
    
        # The "inputs" attribute is used to declare what other flakes this flake depends on
        # it is essentially our dependency list
        inputs = {
            # We can depend on other flakes that are hosted at github by their URL.
            #
            # Nixpkgs is a big set of packages that is almost always depended upon
            # as it contains Nix's standard library.
            #
            # It is possible to pin dependencies to a specific commit (revision)
            # for example in this case we pin to a commit on the nixos-24.05 branch
            # of the "NixOS/nixpkgs" reposityory. We can obtain these either by
            # looking in github directly or by browsing https://status.nixos.org/.
            nixpkgs.url =
              "github:NixOS/nixpkgs?rev=36bae45077667aff5720e5b3f1a5458f51cf0776";
    
            # The nixos-XX.YY branches contain stable packages known to work reliably,
            # however this means that software packaged in that branch might not be the
            # latest available, for that we can declare another version of nixpkgs but
            # picking a revision from the "nixpkgs-unstable" branch which typically
            # has the "latest" available version of most packages:
            unstable.url =
              "github:NixOS/nixpkgs?rev=5de1564aed415bf9d0f281461babc2d101dd49ff";
    
            # Home Manager is distributed as a flake itself, so we add it here as a
            # dependency to our flake, the revision comes from the "release-24.05" branch
            home-manager.url =
              "github:nix-community/home-manager?rev=e1391fb22e18a36f57e6999c7a9f966dc80ac073";
    
            # Since Home Manager is a flake itself written in Nix then it surely declares
            # nixpkgs as one of its dependencies, but since our flake already depends on
            # nixpkgs it would be a bit pointless to download it twice. In this case, we
            # can use "follows" to tell nix that when fetching nixpkgs for satisfying
            # home-manager dependencies it should use the same Nixpkgs version that our
            # flake depends on (that we named above as "nixpkgs").
            home-manager.inputs.nixpkgs.follows = "nixpkgs";
        };
    
        # The "outputs" attribute is a function that takes the "inputs" as parameter
        # (here we unpack it using destructuring) and returns an attribute set
        # (aka an object or dictionary) that defines certain attributes that follow
        # the flake schema.
        outputs = { nixpkgs, unstable, home-manager, ... }:
          let
            # nixpkgs packages software for different architectures in my case
            # I only care about x86_64-linux so I refer to that on its own as "pkgs".
            pkgs = nixpkgs.legacyPackages.x86_64-linux;
    
          in {
            # In this particular case "homeConfigurations" is not part of the official
            # flake schema but is an attribute understood by the home-manager CLI tool.
            #
            # Here we declare a home manager configuration named "demo".
            homeConfigurations.demo =
    
                # home-manager configurations are instantiated by calling the
                # "homeManagerConfiguration" function, giving it an attribute set
                # as its only argument:
                home-manager.lib.homeManagerConfiguration {
    
                  # The attribute set we give to the function expects a "pkgs" attribute
                  # to be defined, it must be a nixpkgs package set, in this case we use
                  # `inherit` as a shortcut for `pkgs = pkgs`.
                  inherit pkgs;
    
                  # Home manager - as well as NixOS - allow us to package our configuration
                  # in modules, at the beginning we might only have a single module but this
                  # can change later, perhaps having a module per application configuration.
                  modules = [
                    # We refer to the file containing our home configuration as a module
                    ./home.nix
                  ];
    
                  # Optionally we can set "extraSpecialArgs" to pass arguments to
                  # home.nix and whatever other modules we might have included in
                  # the "modules" list above
                  extraSpecialArgs = {
                    # As an example we pass the "unstable" version of nixpkgs so that
                    # we're able to use it within the home.nix module.
                    inherit upkgs;
                  };
                };
        }
    }

Now, we need to define the `home.nix` file that we included by path in the
`flake.nix` file:

    { pkgs, upkgs, ... }:
    
    {
      # We might include other modules if we want to organize our configuration in other files:
      imports = [
        ./other-module.nix
      ];
    
      home.username = "demo";
    
      # Install syncthing and enable a systemd service that keeps it running
      services.syncthing.enable = true;
    
      # We can define environment variables we might need
      home.sessionVariables = {
        EDITOR = "nvim";
        COLORTERM = "truecolor";
        TERM = "xterm-256color";
      };
    
      # We can install Emacs and with some extra packages for Emacs to use
      programs.emacs = {
        enable = true;
        extraPackages = epkgs: with epkgs; [ vterm ];
    
        # We can tell it to use "emacs" as it is from the unstable nixpkgs version "upkgs"
        package = upkgs.emacs;
      };
    
      # It is possible to say "put *this* file in *this* location"
      #
      # In this example we use it to "copy" a "ghci" configuration file into
      # our home directory as ".ghci".
      home.file.ghci = {
        enable = true;  # If this is `false` then the file is not copied
        source = ./.ghci;
        target = ".ghci";
      };
    
      # A partial example on how we can install and configure git:
      programs.git = {
        enable = true;
    
        # These are attributes that git expects in its `~/.config/git/config` file
        userName = "demo";
        userEmail = "user@demo.com";
    
        # We can alias commands, e.g. "git graph":
        aliases = {
          graph = "log --all --graph --decorate --oneline";
        };
      };
    
      # This value determines the Home Manager release that our
      # configuration is compatible with. This helps avoid breakage
      # when a new Home Manager release introduces backwards
      # incompatible changes.
      #
      # It is possible to update Home Manager without changing this value.
      #
      # Whenever we use flakes (as we are doing) this value isn't really used
      # because we specifically set the home-manager revision to use as a flake
      # input, however, still must be present in the home configuration so that
      # it does not throws an error about "missing attribute".
      home.stateVersion = "23.11";
    }

This is a bare example that shows how could we use Home Manager to configure
our user-level tools, we can see how not only we&rsquo;re able to install packages
such as Emacs or Git, but also add configuration to them. We can also manage
arbitrary files (`home.file`) and set environment variables (`home.sessionVariables`).

Note that environment variables are only able to get injected if Home manager
also configures our shell, this mentioned in the manual: [Why are the session
variables not set?](https://nix-community.github.io/home-manager/index.xhtml#_why_are_the_session_variables_not_set), in the example above we did not configure our shell so if
we wanted to see those variables we need to source a script home-manager
installs, but, adding our shell configuration to home-manager is trivial.

    # This might be the contents of other-module.nix, whatever floats your boat!
    { ... }:
    {
      # ...
      # Install and configure Zshell
      programs.zsh = {
        enable = true;
        autosuggestion.enable = true;
        enableCompletion = true;
        autocd = true;
        defaultKeymap = "emacs";
        dotDir = ".config/zsh"; # Where to place zsh config?
    
        # Define some shell aliases
        shellAliases = {
          cat = "bat -p";
          cd = "z";
          gs = "git status";
          l = "ls -alh";
          ll = "ls -l";
          ls = "ls --color=tty";
          lt = "ls -thalr";
        };
    
        # Use the popular Oh-My-Zsh distribution
        oh-my-zsh = {
          enable = true;
          plugins = [ "git" "direnv" "fzf" ];
          theme = "robbyrussell";
        };
      };
      # ...
    }

What options are available to set can be seen in the manual [Appendix A. Home
Manager Configuration Options](https://nix-community.github.io/home-manager/options.xhtml), but I also suggest using other resources such as [Home Manager Option Search](https://home-manager-options.extranix.com/).

Now its all fun and games till we want to apply our configuration,
the very first time you&rsquo;d want to run this:

    $ nix run home-manager/release-24.05 -- init --switch

That will activate a shell with home-manager available and enable your
configuration for the first time ever. After that whenever the configuration
is changed we need to execute `home-manager` to activate it:

    $ home-manager switch --flake .#demo

We use &ldquo;demo&rdquo; here because that&rsquo;s the name we gave to our home-manager
configuration within the `flake.nix` file.


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
