   <meta charset="utf-8" emacsmode="-*- markdown -*-"> <link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/journal.css?">

                        **Yaml Resume Database**
                           Version 1.1


Json Resume is a great way to keep your resume updated.
However there two things missing:

1. Json its an ugly format to look by hand.
2. It would be nice to build a database of the knowledge and skills of team,
   based on their json resume.



2025-01-12: Starting the project
=================================================================

In order to start this project I need:

1. A couple of json resumes
1. the json schema of json resumes.
1. Translate the json schema to a terminus db instance.
1. insert the json resume in terminusdb
1. query the terminusdb  to get the tag cloud of projects we know on.

Now I hope to make this document a literate program.
So let's see how far I get it to be.

Get a couple of json resumes
---------------------------------------------------------------

```nushell
    $ mkdir test
    $ http get https://gist.githubusercontent.com/thomasdavis/c9dcfa1b37dec07fb2ee7f36d7278105/raw/c0399b7abb13fe63912843ca6f6c90af63fb28ae/resume.json |
    > save --force test/1.json
    $ http get https://gist.githubusercontent.com/elviejo79/ab0802ef51ac9f53defe686e7fae452b/raw/1d0be3cb5c3fb03259a1141779b632397524cb55/resume.json |
    > save --force test/2.json
```


Let's get the schema to validate the files

```nushell
    $ http get https://raw.githubusercontent.com/jsonresume/resume-schema/v1.0.0/schema.json |
    > save test/old.schema.json
```

The schema that is in json schema store is for draf-04 of schema specification.
And we need to update. it

```nushell
    > ajv migrate -s test/old.schema.json -o test/resume.schema.json
```


We also must make sure that they are
[valid json resumes according to the schema](https://chatgpt.com/share/67849193-d2c0-8007-82ce-26ae4d84f5d9).

```nushell
    $ ajv validate -s test/resume.schema.json -d test/1.json --strict=false -c ajv-formats
    $ ajv validate -s test/resume.schema.json -d test/2.json --strict=false -c ajv-formats
```

2025-01-17 Transform the json_resume.scha to terminsdb schema
================================================================
It took me 5 days of 14 hours to create this migration script from jsonata.
But now I can automaticall translate from json_resume.schema to terminusdb.schema.

!!! note
    I hope someday this transformation script can transform all the json schemas to jsonata.

so now let's execute the jsonata query that transforms this one schema

```nushell
   $ cat test/resume.schema.json | jfq --query-file test/resume_schema_to_terminusdb.jsonata | save --force test/terminus.resume.schema.json
```

So simple and yet that query has been one of the most difficult things I've written.

What should I do next?
---------------------------------------------------------------

[ ] Mutate one of the example resumes so that is almos the same as another
    To demonstrate that eventhough we are storing several resumes.
    The quantity of entinties in the database doesn't grow because the entities are the same
    Just linked from different documents
[ ] Maybe run the schema commands by hand. So that I get to learn what I need to write.
[ ] Personalize the resume_schema_to_terminusdb.json I think the main table JSON_RESUME
    shouldn't have the @unfolded:[] key BUT  maybe it does... I need to check it.
[ ] Run terminusdb store init to create a new storage
[ ] Think I'll need to set up the routes of the schema and the instances... although I don't know how
[ ] Once the schema is created by hand:
    Try to insert 3 resumes!
[ ] Run queries to show that eventhough you inserted 3 resumes you don't have 3 different entities
    They should repeat!
[ ] Once I know the process by hand:
    try to pipe resume_schema_to_terminusdb.json file | terminusdb db doc -g

2025-01-19 Let's try to make the schema run in TermunsDB
==============================================================================

Are you feeling lucky?
----------------------------
First let's try to see if we are lucky and all of our generated schema works.

```nushell
    $ tdb-cli doc insert family --full-replace --graph_type schema < ./test/terminus.resume.schema.json
    Too many arguments to parse an organizatin
```
Ok no luck.


One by one it is
----------------------------

So now let's do it one by one:

```nushell
    $ "
    > {
    >  "@id": "PROFILES",
    >  "@type": "class",
    >  "@unfolded": [],
    >  "network": "xsd:string",
    >  "url": "xsd:uri",
    >  "username": "xsd:string"
    > }
    > " | save --force ./test/test_one_schema.json
```

```nushell
    $ tdb-cli doc insert family --full-replace --graph_type schema < ./test/test_one_schema.json
    Too many arguments to parse an organization
```

Ok so what is the current `family` schema (`family`) is just what I inhereted from the tutorial
I'm following.

```nushell
    $ tdb-cli doc get family --graph_type schema | tee ./test/current_organization.json
    {"@base":"terminusdb:///data/", "@schema":"terminusdb:///schema#", "@type":"@context"}
```

let me append it to prepend it to the one schema we have:

```nushell
    $ tdb-cli doc get family --graph_type schema |
    > tee ./test/current_organization.json
    $ cat ./test/current_organization.json ./test/test_one_schema.json |
    > cat ./test/current_organization.json ./test/test_one_schema.json |
    > tdb-cli doc insert family --full-replace --graph_type schema
    {"@type":"api:InsertDocumentErrorResponse", "api:error": {"@type":"api:UnknownSchemaType", "api:type":"class"}, "api:message":"The '@type' field referred to an unimplemented schema type.", "api:status":"api:failure"}
```

Ok so it seems the organization problem is over,
now I need to chek the *class* word.
looking at the tutorials seems that it should be "Class"

```nushell
    $ "{
        "@id": "PROFILES",
        "@type": "Class",
        "@unfolded": [],
        "network": "xsd:string",
        "url": "xsd:uri",
        "username": "xsd:string"
      }" | save --force ./test/test_one_schema.json
```

Next attempt
```nushell
    $ cat ./test/current_organization.json ./test/test_one_schema.json |
    > tdb-cli doc insert family --full-replace --graph_type schema | jfq
    {
      "@type": "api:InsertDocumentErrorResponse",
      "api:error": {
        "@type": "api:SchemaCheckFailure",
        "api:witnesses": [
          {
            "@type": "not_a_class_or_base_type",
            "class": "http://www.w3.org/2001/XMLSchema#uri"
          }
        ]
      },
      "api:message": "Schema check failure",
      "api:status": "api:failure"
    }
```
Ok `uri` is not recognized as a valid type.
What happens If I just eliminate it from the data.
Now I'm going to use jfq to modify the json schema

```nushell
    $ cat ./test/terminus.resume.schema.json | jfq '($[`@id`="PROFILES"] ~>|$|{"@type":"Class"},["url"]|)' | save --force ./test/test_one_schema.json
    $ cat ./test/current_organization.json ./test/test_one_schema.json | tdb-cli doc insert family --full-replace --graph_type schema | jfq
    PROFILES
```

Success!!!

Now let's put the url back
---------------------------------------------------------------


```nushell
    $ cat ./test/terminus.resume.schema.json | jfq '($[`@id`="PROFILES"] ~>|$|{"@type":"Class", "url":"xsd:anyURI"}|)' | save --force ./test/test_one_schema.json
    $ cat ./test/current_organization.json ./test/test_one_schema.json | tdb-cli doc insert family --full-replace --graph_type schema | jfq
    PROFILES
```

Double success!!!

Now let's make all the corrections to the transformer.
----------------------------
Ok now let's try our luck one more time with all the json schema.
but with the Class correction and xsd:anyURI
for that will change the original jsonata query.

```nushell
    $ pbpaste |
    save --force test/transform_json_resume_schema_to_terminusdb_schema.jsonata ;
    cat ./test/resume.json_schema |
    jfq --query-file test/transform_json_resume_schema_to_terminusdb_schema.jsonata |
    tee { save --force ./test/resume.terminus_schema} | tdb-cli doc insert family --full-replace --graph_type schema | jfq


    JSON_RESUME
    BASICS
    WORK
    VOLUNTEER
    EDUCATION
    AWARDS
    CERTIFICATES
    PUBLICATIONS
    SKILLS
    LANGUAGES
    INTERESTS
    REFERENCES
    PROJECTS
    META
    LOCATION
    PROFILES
```

Triple success!!!

Lets prepare for the next steps
---------------------------------------------------------------

I'll still need to continue to improve the jsonata transformer.
so might as well automate the testing of my variatons

```nushell
    pbpaste | save --force "test/resume_instance_transformer_with_schema.jsonata" |
    cat ./test/resume_instance_transformer_with_schema.jsonata
```

Esta es la parte reptitiva si no has cambiado la query en jsonata explorer

```nushell
    cat test/resume.json_schema | jfq --query-file test/transform_json_resume_schema_to_terminusdb_schema.jsonata | save --force ./test/resume.terminus_schema;
    cat test/resume.terminus_schema | tee { tdb-cli doc insert family --full-replace --graph_type schema | jfq}
```

Could I store a json resume
----------------------------

```nushell
$ tdb-cli doc insert family < ./test/1.json
Too many arguments to parse an organization
$ tdb-cli doc insert family/JSON_RESUME < ./test/1.json
Too many arguments to parse an organization
$ tdb-cli doc insert admin/family  < ./test/1.json
```

It seems I need to skip validations :-(
```nushell
    $ cat ./test/2.json | tdb-cli doc insert --raw-json admin/family
["terminusdb:///data/JSONDocument/7EtuLipEyOCx9Nb-" ]

```

However it does insert *a* json

```nushell
    $ tdb-cli doc get admin/family --id JSONDocument/7EtuLipEyOCx9Nb- | jfq
```

And it works!!!

BUT BUT

It's storinga single json document.
NOT all the previous subdocuments.

2025-01-20
==================================================
What is happening is that the actual json_resumes have:
- Extra properties, like website. that are not part of the schema
- lacking properties, that are optional en json schema, but in terminusdb are mandatory.

And this comes from the fact that in, json_schema all properties are optional unless marked as required.
allowing even "additionalInfo" properties.
And in terminusdb is exactly the opposite every property is mandatory, unless marked as optional.
And it doesn't allow extra fields!

I have work around
----------------------------
In this conversation with chatgpt inspired me with the solution:
https://chatgpt.com/share/678e916a-1304-8007-8aa8-32b84d50dbbe

For this fields that are NOT part of the json.schema I need to classify them in a field
called metadata. And then In that field create store extra json fields.

Changes to the schema_transformer and the instance_transformer
----------------------------
Because it implied changes to the schema_transformer and the instance_transformer

And yes I was able to create such a query.
It needed to change schema transformer
and also query that process the resume.
and I need another query that compares the original resume against the json_schema

``` nushell
    $ pbpaste | save --force "test/resume_instance_transformer_with_schema.jsonata" |
    cat ./test/resume_instance_transformer_with_schema.jsonata |
    echo $"\{\"original_resume\": (cat ./test/1.json), \n \"terminus_schema\": (cat ./test/resume.terminus_schema) \}" | jq |
    tee { save --force "./test/tmp_1.json"} |
    jfq --query-file ./test/resume_instance_transformer_with_schema.jsonata | jq |
    tee {save --force ./test/terminus.1.json } |
    tdb-cli doc insert admin/family | jq | pbcopy
```

What should I try next
----------------------------
I will tri to feed terminus.1.json part by part :-(

this works now:
```nushell
    ./jresume_transformer init_terminus
    ./jresume_transformer replace_terminus_schema
    #this one tries to insert the whole resume and fails, but is necessary to run it becaus it create temp files
    ./jresume_transformer insert_a_resume 2
    ./jresume_transformer insert_single_table 2 skills
```



<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
